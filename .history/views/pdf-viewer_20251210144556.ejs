<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDF Viewer â€” StoreM</title>
  <style>
    html,body{height:100%;margin:0;background:#111;color:#fff;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
    #viewer { position:fixed; inset:0; display:flex; flex-direction:column; }
    #toolbar { display:flex; gap:8px; padding:8px; background:#0f0f0faa; align-items:center }
    button { padding:8px 10px; border-radius:6px; border:1px solid rgba(255,255,255,0.06); background:rgba(0,0,0,0.6); color:#fff; cursor:pointer }
    #canvasWrap { flex:1; overflow:auto; display:flex; align-items:center; justify-content:center; background:#000; position:relative }
    canvas { box-shadow:0 6px 30px rgba(0,0,0,0.6); }
    #status{margin-left:8px;color:#ddd}
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    // Only PRODUCT_ID is needed now; no VIEW_TOKEN or watermark keys
    const PRODUCT_ID = "<%= (typeof productId !== 'undefined' ? productId : (product && product._id) ? product._id : '') %>";
  </script>
</head>
<body>
  <div id="viewer">
    <div id="toolbar">
      <button id="prev">Prev</button>
      <button id="next">Next</button>
      <button id="zoomOut">-</button>
      <button id="zoomIn">+</button>
      <span id="status">Loading...</span>
      <div style="flex:1"></div>
      <button id="fullscreen">Fullscreen</button>
    </div>
    <div id="canvasWrap">
      <canvas id="pdfCanvas"></canvas>
    </div>
  </div>

  <script>
    const pdfjsLib = window['pdfjs-dist/build/pdf'];
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    const canvas = document.getElementById('pdfCanvas');
    const ctx = canvas.getContext('2d');
    const status = document.getElementById('status');

    let pdfDoc = null;
    let currentPage = 1;
    let scale = 1.2;

    // Block easy download/print via shortcuts/context menu (best-effort)
    document.addEventListener('contextmenu', e => e.preventDefault(), {capture:true});
    window.addEventListener('keydown', (e)=>{
      if ((e.ctrlKey || e.metaKey) && ['s','p','S'].includes(e.key)) { e.preventDefault(); e.stopPropagation(); }
      if (e.key === 'F12' || (e.ctrlKey && e.shiftKey && ['I','C','J'].includes(e.key.toUpperCase()))) { e.preventDefault(); e.stopPropagation(); }
    }, {capture:true});

    async function fetchPdfArrayBuffer(){
      if (!PRODUCT_ID) throw new Error('PRODUCT_ID not provided');
      const url = `/pdf/${PRODUCT_ID}`;
      const resp = await fetch(url, { method: 'GET', credentials: 'same-origin' });
      if (!resp.ok) throw new Error('Failed to fetch PDF: ' + resp.status + ' ' + resp.statusText);
      return await resp.arrayBuffer();
    }

    async function loadPdf(){
      status.textContent = 'Loading PDF...';
      try {
        const ab = await fetchPdfArrayBuffer();
        const loadingTask = pdfjsLib.getDocument({ data: ab });
        pdfDoc = await loadingTask.promise;
        status.textContent = `Pages: ${pdfDoc.numPages}`;
        renderPage(currentPage);
      } catch (err) {
        console.error('PDF load error', err);
        status.textContent = 'Unable to load PDF';
      }
    }

    async function renderPage(pageNum){
      status.textContent = `Rendering ${pageNum}/${pdfDoc.numPages}`;
      const page = await pdfDoc.getPage(pageNum);
      const viewport = page.getViewport({ scale });
      canvas.width = viewport.width;
      canvas.height = viewport.height;
      const renderContext = { canvasContext: ctx, viewport };
      await page.render(renderContext).promise;
      status.textContent = `Page ${pageNum} / ${pdfDoc.numPages}`;
    }

    document.getElementById('prev').addEventListener('click', ()=>{ if (currentPage>1){ currentPage--; renderPage(currentPage); } });
    document.getElementById('next').addEventListener('click', ()=>{ if (currentPage < pdfDoc.numPages){ currentPage++; renderPage(currentPage); } });
    document.getElementById('zoomIn').addEventListener('click', ()=>{ scale = Math.min(3, scale + 0.2); renderPage(currentPage); });
    document.getElementById('zoomOut').addEventListener('click', ()=>{ scale = Math.max(0.4, scale - 0.2); renderPage(currentPage); });
    document.getElementById('fullscreen').addEventListener('click', async ()=>{ try{ if (!document.fullscreenElement) await document.documentElement.requestFullscreen({ navigationUI: 'hide' }); else await document.exitFullscreen(); }catch(e){console.warn(e);} });

    window.addEventListener('beforeunload', ()=>{ try{ const url = `/notes/${PRODUCT_ID}/cleanup-pages`; if (navigator.sendBeacon) navigator.sendBeacon(url, new Blob([], {type:'application/octet-stream'})); }catch(e){} });

    loadPdf();
  </script>
</body>
</html>
