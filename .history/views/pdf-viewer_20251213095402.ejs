<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDF Viewer — StoreM</title>
  <style>
    html,body{height:100%;margin:0;background:#111;color:#fff;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
    #viewer { position:fixed; inset:0; display:flex; flex-direction:column; }
    #toolbar { display:flex; gap:8px; padding:8px; background:#0f0f0faa; align-items:center }
    button { padding:8px 10px; border-radius:6px; border:1px solid rgba(255,255,255,0.06); background:rgba(0,0,0,0.6); color:#fff; cursor:pointer }
    #canvasWrap { flex:1; overflow:auto; display:flex; align-items:center; justify-content:center; background:#000; position:relative }
    canvas { box-shadow:0 6px 30px rgba(0,0,0,0.6); }
    #status{margin-left:8px;color:#ddd}
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    // PRODUCT_ID and optional VIEW_TOKEN (short-lived) — VIEW_TOKEN is injected by the server when available
    const PRODUCT_ID = "<%= (typeof productId !== 'undefined' ? productId : (product && product._id) ? product._id : '') %>";
    const VIEW_TOKEN = "<%= (typeof token !== 'undefined' ? token : '') %>";
    const IMAGE_URL = "<%= (typeof imageUrl !== 'undefined' ? imageUrl : '') %>";
    const CURRENT_PAGE_SERVER = <%= (typeof currentPage !== 'undefined' ? Number(currentPage) : 1) %>;
    const TOTAL_PAGES_SERVER = <%= (typeof totalPages !== 'undefined' ? Number(totalPages) : 0) %>;
    const ORDER_ID = "<%= (typeof orderId !== 'undefined' ? orderId : '') %>";
    const PRODUCT_PAGES = <%- JSON.stringify((typeof product !== 'undefined' && product && product.page_images) ? product.page_images : []) %>;
  </script>
</head>
<body>
  <div id="viewer">
    <div id="toolbar">
      <button id="prev">Prev</button>
      <button id="next">Next</button>
      <button id="zoomOut">-</button>
      <button id="zoomIn">+</button>
      <label style="margin-left:8px;display:flex;align-items:center;gap:6px;color:#ddd;">
        <span style="font-size:0.9rem;color:#ddd;">Go to</span>
        <input id="pageInput" type="number" min="1" value="1" style="width:72px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.08);background:transparent;color:#fff;" />
        <button id="gotoBtn">Go</button>
      </label>
      <span id="status">Loading...</span>
      <div style="flex:1"></div>
      <button id="fullscreen">Fullscreen</button>
    </div>
    <div id="canvasWrap">
      <canvas id="pdfCanvas" style="display:none;"></canvas>
      <img id="pageImage" src="" alt="page image" style="max-width:100%; max-height:100%; display:none; object-fit:contain;" />
    </div>
  </div>

  <script>
    const pdfjsLib = window['pdfjs-dist/build/pdf'];
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    const canvas = document.getElementById('pdfCanvas');
    const ctx = canvas.getContext('2d');
    const status = document.getElementById('status');

    let pdfDoc = null;
    let currentPage = Number(CURRENT_PAGE_SERVER) || 1;
    let scale = 1.2;

    // Block easy download/print via shortcuts/context menu (best-effort)
    document.addEventListener('contextmenu', e => e.preventDefault(), {capture:true});
    window.addEventListener('keydown', (e)=>{
      if ((e.ctrlKey || e.metaKey) && ['s','p','S'].includes(e.key)) { e.preventDefault(); e.stopPropagation(); }
      if (e.key === 'F12' || (e.ctrlKey && e.shiftKey && ['I','C','J'].includes(e.key.toUpperCase()))) { e.preventDefault(); e.stopPropagation(); }
    }, {capture:true});

    async function fetchPdfArrayBuffer(){
      if (!PRODUCT_ID) throw new Error('PRODUCT_ID not provided');
      const tokenParam = VIEW_TOKEN ? `?token=${encodeURIComponent(VIEW_TOKEN)}` : '';
      const sep = PRODUCT_ID.includes('?') ? '&' : '?';
      const url = `/pdf/${PRODUCT_ID}${tokenParam ? sep + 'token=' + encodeURIComponent(VIEW_TOKEN) : ''}`;
      const resp = await fetch(url, { method: 'GET', credentials: 'same-origin' });
      if (!resp.ok) throw new Error('Failed to fetch PDF: ' + resp.status + ' ' + resp.statusText);
      return await resp.arrayBuffer();
    }

    async function loadPdf(){
      status.textContent = 'Loading PDF...';
      try {
        const ab = await fetchPdfArrayBuffer();
        const loadingTask = pdfjsLib.getDocument({ data: ab });
        pdfDoc = await loadingTask.promise;
        status.textContent = `Pages: ${pdfDoc.numPages}`;
        renderPage(currentPage);
      } catch (err) {
        console.error('PDF load error', err);
        status.textContent = 'Unable to load PDF';
      }
    }

    async function renderPage(pageNum){
      if (!pdfDoc) return;
      status.textContent = `Rendering ${pageNum}/${pdfDoc.numPages}`;
      const page = await pdfDoc.getPage(pageNum);
      const viewport = page.getViewport({ scale });
      canvas.width = viewport.width;
      canvas.height = viewport.height;
      const renderContext = { canvasContext: ctx, viewport };
      await page.render(renderContext).promise;
      status.textContent = `Page ${pageNum} / ${pdfDoc.numPages}`;
      document.getElementById('pageInput').value = pageNum;
    }

    const prevBtn = document.getElementById('prev');
    const nextBtn = document.getElementById('next');
    const pageInput = document.getElementById('pageInput');
    const gotoBtn = document.getElementById('gotoBtn');

    prevBtn.addEventListener('click', ()=>{
      if (IMAGE_URL) {
        // image-mode: navigate to previous page route
        const prev = Math.max(1, Number(currentPage) - 1);
        if (prev === Number(currentPage)) return;
        const t = VIEW_TOKEN ? `?token=${encodeURIComponent(VIEW_TOKEN)}` : '';
        window.location.href = `/notes/${ORDER_ID}/page/${prev}${t}`;
        return;
      }
      if (currentPage>1){ currentPage--; renderPage(currentPage); }
    });

    nextBtn.addEventListener('click', ()=>{
      if (IMAGE_URL) {
        const next = Number(currentPage) + 1;
        if (PRODUCT_PAGES && PRODUCT_PAGES.length && next > PRODUCT_PAGES.length) return;
        const t = VIEW_TOKEN ? `?token=${encodeURIComponent(VIEW_TOKEN)}` : '';
        window.location.href = `/notes/${ORDER_ID}/page/${next}${t}`;
        return;
      }
      if (pdfDoc && currentPage < pdfDoc.numPages){ currentPage++; renderPage(currentPage); }
    });
    document.getElementById('zoomIn').addEventListener('click', ()=>{ scale = Math.min(3, scale + 0.2); renderPage(currentPage); });
    document.getElementById('zoomOut').addEventListener('click', ()=>{ scale = Math.max(0.4, scale - 0.2); renderPage(currentPage); });
    document.getElementById('fullscreen').addEventListener('click', async ()=>{ try{ if (!document.fullscreenElement) await document.documentElement.requestFullscreen({ navigationUI: 'hide' }); else await document.exitFullscreen(); }catch(e){console.warn(e);} });

    window.addEventListener('beforeunload', ()=>{ try{ const url = `/notes/${PRODUCT_ID}/cleanup-pages`; if (navigator.sendBeacon) navigator.sendBeacon(url, new Blob([], {type:'application/octet-stream'})); }catch(e){} });

    // Goto handling (works in both PDF and image modes)
    gotoBtn.addEventListener('click', ()=>{
      const val = Number(pageInput.value || 0);
      if (!val || val < 1) return;
      if (IMAGE_URL) {
        // validate against available product pages
        if (!PRODUCT_PAGES || !PRODUCT_PAGES.length) return;
        const pageNum = Math.min(Math.max(1, Math.floor(val)), PRODUCT_PAGES.length);
        const t = VIEW_TOKEN ? `?token=${encodeURIComponent(VIEW_TOKEN)}` : '';
        window.location.href = `/notes/${ORDER_ID}/page/${pageNum}${t}`;
        return;
      }
      // PDF mode — wait for pdfDoc to be available
      if (pdfDoc) {
        const pageNum = Math.min(Math.max(1, Math.floor(val)), pdfDoc.numPages);
        currentPage = pageNum;
        renderPage(currentPage);
      } else {
        // store desired page and navigate after load
        currentPage = Math.max(1, Math.floor(val));
        // nothing else — loadPdf will render currentPage after load
      }
    });

    // If IMAGE_URL provided, show image mode; otherwise load full PDF
    (async function init(){
      if (IMAGE_URL) {
        // Image mode (single page view). Show image and hide canvas.
        const imgEl = document.getElementById('pageImage');
        const canvasEl = document.getElementById('pdfCanvas');
        canvasEl.style.display = 'none';
        imgEl.style.display = 'block';
        imgEl.src = IMAGE_URL;
        // set page input to current page
        pageInput.value = currentPage;
        // hide prev/next if only one product page
        if (!PRODUCT_PAGES || PRODUCT_PAGES.length <= 1) {
          prevBtn.style.display = 'none'; nextBtn.style.display = 'none';
        }
        status.textContent = `Page ${currentPage}`;
      } else {
        // PDF mode
        document.getElementById('pageImage').style.display = 'none';
        document.getElementById('pdfCanvas').style.display = 'block';
        await loadPdf();
        // hide prev/next if only 1 page
        if (pdfDoc && pdfDoc.numPages <= 1) { prevBtn.style.display = 'none'; nextBtn.style.display = 'none'; }
        // set input max if available
        pageInput.max = pdfDoc ? pdfDoc.numPages : '';
      }
    })();
  </script>
</body>
</html>
